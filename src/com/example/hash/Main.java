package com.example.hash;

public class Main {

	/*
	 *  哈希表是基于数组的
	 * 
	 *  将关键字转成数组下标
	 *  
	 *  幂的连乘
	 *  对7564这个数字使用幂的连乘：7*10^3 + 5*10^2 + 6*10^2 + 4*10^0
	 *  把cats按字母转换成数字代码进行幂的连乘：3*27^3 + 1*27^2 + 20*27^1 + 19*27^0
	 *  
	 *  问题：为每个可能的单词分配了一个数组单元，但大部分分配的内存位置都是空的
	 *  
	 *  哈希化
	 *  把数位幂的连乘中得到的巨大整数范围压缩到可接受的数组范围中
	 *  比如50000个单词，最多就是要给它分配100000容量的数组
	 *  采用取余操作可以做到：
	 *  举例：
	 *  把0到199的数字（用变量largeNumber表示），压缩为0到9的数字（用变量smallNumber表示）
	 *  后者有10个数，所以说变量smallRange值为10，则
	 *  smallNumber = largeNumber % smallRange;
	 *  一个数被10整除时，余数一定在0到9之间。
	 *  
	 *  也可以用类似的方法把表示单词的唯一的数字压缩成数组的下标：
	 *  arrayIndex = hugeNumber % arraySize;
	 *  
	 *  这种取余操作就是一种哈希函数：
	 *  把一个大范围的数字哈希化成一个小范围的数字，这个小范围对应这数组的下标。
	 *  使用哈希函数向数组插入数据后，这个数组就称为哈希表。
	 *  
	 *  哈希函数具体操作：
	 *  把单词每个字母乘以27的适当次幂，是单词成为一个巨大的数字，然后使用取余操作符，
	 *  把得到的巨大整数范围转换成两倍于要存储内容的数组下标范围：
	 *  arraySize = numberWords * 2; 
	 *  arrayIndex = hugeNumber % arraySize;
	 *  
	 *  简单说哈希函数：
	 *  假设数据是50000，先将数据*2，即100000，100000作为数组分配数组的最大范围
	 *  然后对50000作幂次操作，会得到一个庞大的数字，对这个庞大数字与*2后的数组最大范围取余操作，得到的数字将作为该数据在数组中的下标。
	 *  
	 *  哈希函数的冲突：把一个巨大的整数范围压缩为小范围的数组范围，有时候不可避免的计算出相同范围而数组范围已被占用导致冲突
	 *  
	 *  冲突解决：
	 *  （1）开放地址法：通过系统的方法找到数组的一个空位，并把这个单词填入，不再用哈希函数得到数组下标
	 *  查找下一个空白单元的三种方法：
	 *  [1]线性探测：假设5421是要插入的位置，它已经被占用，则递增数组下标直到找到空位（会出现聚集，成为原始聚集）。
	 *  [2]二次探测：防止线性探测后大量数据的聚集导致降低哈希表性能，探测相隔较远的单元（同样会引来聚集，称为二次聚集，所以不经常使用）。
	 *  [3]再哈希法（通常使用该方法）：消除原始聚集和二次聚集，依赖关键字的探测，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。
	 *  	把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为步长进行空位探测。
	 *  这个哈希函数必须具备如下特点：
	 *  <1>和第一个哈希函数不同
	 *  <2>不能输出0（否则，将没有步长陷入死循环）
	 *  stepSize = constant - (key % 5) constant是质数，且小于数组容量
	 *  （2）链地址法：创建一个存放单词链表的数组，数组内不直接存储单词。
	 *  
	 *  
	 */
	
	public static void main(String[] args) {
		
	}
	
}
